/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Error Handling
* Version           -> 1.0.0.0528
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 28.05.2018 06:38:46
* Description       -> Description
*
*	Aufbau des Fehlerspeichers.:
*
*	*->buff[ID][NUM] -> ID = Fehler Typ (I2C , USART , LCD usw.).
*						NUM = Fehler die Aufgetreten sind ( Anzahl der zu speichernden -
*							  Fehler hängt von "ERROR_BUFFER_ID_SIZE" ab.
*	
*	WICHTIG! -> Es dürfen keine Fehler <= 0x00 eingetragen werden.
*				z.B -> errorWrite( &err , 0x01 ,  *0x00 ); *Ist nicht zulässig
*
*
*	Vor dem Zugriff auf den Fehlerspeicher ( lesen oder schreiben ) muss dieser 
*	initalisiert werden ( errorInit( &err ) ).
*
*	Die "länge" des Fehlerspeichers wird mit "ERROR_BUFFER_LENG" bestimmt
*	Die anzahl der verschiedenen Fehlertypen (ID´s) wird anhand von "err_id" bestimmt.
*
*	z.B.:	ID	|	ERR 
*		   -----|----------------
*			0	| 1 , 4 , 2 , 5 , 1
*			1	| 5 , 7 , 8 , 32 , 212
*			...	|
*/

#ifndef __ERROR_H__
#define __ERROR_H__


#define ERROR_BUFFER_LENG		5

#include <stdint.h>

enum err_id
{
	_ERROR_GLCD_I2C_,
	_ERROR_RTC_I2C_,
	_ERROR_SHT21_I2C_,
	_ERROR_BMP180_I2C_,
	
	
	/*
	*	Darf nicht verändert werden
	*/
	_ERROR_NUM_OF_ID_
};

/*
*	Darf nicht geändert werden!
*/
#define	ERROR_BUFFER_ID_SIZE	_ERROR_NUM_OF_ID_
#define ERROR_ENTRYS			0

enum i2c_err_nums
{
	/*
	*	Darf nicht verändert werden!
	*	Muss stehen bleiben.
	*	( Fehlerkodes dürfen nicht <= 0 sein )
	*/
	DONT_USE_IT,
	
	/*
	*	Ab hier dürfen eigene Fehlerkodes ( uint8_t ) 
	*	eingetragen werden.
	*/
	ERROR_I2C_NO_ACK,
	ERROR_I2C_ADDRESS_TX,
	ERROR_I2C_BYTE_TX,
};

typedef struct
{
	#define ERROR_ID	0
	#define ERROR_BEGIN	1
	
	/*
	*	Fehlerspeicher
	*/
	uint8_t buff[ERROR_BUFFER_ID_SIZE][ERROR_BUFFER_LENG + 1];
	
	/*
	*	Anzahl der befindlichen Meldungen im Fehlerspeicher
	*/
	uint16_t len;
	
	/*
	*	Welche Art von Fehler ist aufgetreten?!
	*	
	*	z.B.: UART , LCD , I2C usw.
	*/
	uint8_t id;
	
	/*
	*	Letzte Fehlermeldung
	*/
	uint8_t lastErr;
	
	/*
	*	Zähler für aufgetretene Fehler
	*/
	uint8_t err[ERROR_BUFFER_ID_SIZE][1];
	
}error_t;

extern error_t err;




/* errorInit
* @para             -> Fehlerstruktur ( error_t )
* @return           -> 0 = alles inordnung
* @description      -> Muss aufgerufen werden bevor überhaupt irgendein
					   Zugriff auf den Fehlerspeicher erfolgt
*/
uint8_t errorInit( error_t *strc );

/* errorWrite
* @para             -> Fehlerstruktur ( error_t ) , Fehler ID ( id ) ,
* @return           -> 0 = alles inordnung
*					   1 = Kompletter Fehlerspeicher ist belegt
*					   2 = Für diese ID ist kein Speicherplatz vorhanden
*					   3 = 30 + ID = ID Fehlerspeicher ist komplett belegt
*					   4 = Fehlermeldung ist <= 0
*		
* @description      -> Fehler + Fehler ID´s werden in den Speicher geschrieben
*/
uint8_t errorWrite( error_t *strc , uint8_t id , uint8_t err );

/* errorWriteCircular
* @para             -> Fehlerstruktur ( error_t ) , Fehler ID ( id ) ,
* @return           -> 0 = alles inordnung
*					   2 = Für diese ID ist kein Speicherplatz vorhanden
*					   4 = Fehlermeldung ist <= 0
*
* @description      -> Fehler + Fehler ID´s werden in den Speicher geschrieben
*					   Hier werden die Fehlermeldungen im "Kreis geschrieben.
					   Sollten die Fehler größer als ERROR_BUFFER_LENG werden,
					   wird ab ERROR_BEGIN die neuen Fehler eingetragen.
*/
uint8_t errorWriteCircular( error_t *strc , uint8_t id , uint8_t err );

/* errorClear
* @para             -> Fehlerstruktur ( error_t ) , Fehler ID ( id )
* @return           -> 0 = alles inordnung
* @description      -> -none
*/
void errorClear( error_t *strc , uint8_t id );

/* errorFreeSize
* @para             -> Fehlerstruktur ( error_t ) , Fehler ID ( id )
* @return           -> x = Anzahl freier Speicherplätze
* @description      -> Gibt den noch freien Speicherplatz für die jeweilige ID zurück
*/
uint8_t errorFreeSize( error_t *strc , uint8_t id );

/* errorGetExist
* @para             -> Fehlerstruktur ( error_t )
* @return           -> Zeiger auf den Fehlerstring oder wenn nicht vorhanden "NULL"
* @description      -> Gibt alle vorhanden Fehlermeldungen zurück der vorhandenen ID´s
*					   <0#1,2,3,4> oder <4#4,3,1,2,4>
*/
char *errorGetExist( error_t *strc );

/* errorGetExist
* @para             -> Fehlerstruktur ( error_t )
* @return           -> Zeiger auf den Fehlerstring oder wenn nicht vorhanden "NULL"
* @description      -> Gibt den Fehlerstring der Fehler ID zurück
*					   <0#1,2,3,4> oder <4#4,3,1,2,4>
*/
char *errorGetById( error_t * strc , uint8_t id );


#endif